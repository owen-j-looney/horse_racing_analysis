---
title: "Horse Racing Analysis"
author: "Owen Looney"
date: "20/04/2022"
output:
  html_document: default
---

```{r setup, include=FALSE}
library(rvest)
library(xml2)
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(curl)
library(glue)
library(ggplot2)
library(caret)
library(nnet)
library(NeuralNetTools)
library(knitr)
library(reactable)
library(lubridate)

knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	comment = FALSE,
	opts.label="kill_prefix"
)
```


## Introduction

This analysis devles into horse racing data, and attempting to identify ways to predict which horse will win, and a potential way to make a profit from betting on horse racing in Australia with reduced risk. 

The horse racing data was sourced from the Racing Australia [website](https://www.racingaustralia.horse/Home.aspx) under the racing results tab. The Racing Australia website only stores data for the previous month of races, however it does include trial runs. The race data includes information such as the barrier, weight the horse is carrying, the trainer, the jockey, the date, the track, among many other attributes. The position of the horse at the end of the race, and the length the horse lost by (in lengths) are also included in the data, however lengths is an arbitrary unit of distance, so this was converted to metres by assuming a single horse length was 2.5 metres. 

Below shows the scraping of the horse racing data from the web, along with an example of what the horse racing data initially looks like.

```{r data download and clean, echo=TRUE}

#getting required urls
base_url <- "https://www.racingaustralia.horse/FreeFields/Calendar_Results.aspx"

state_list <- c("NSW",
                "QLD",
                "ACT",
                "VIC",
                "TAS",
                "SA",
                "WA",
                "NT")

#creating blank list so i can get a url for race results for each state
state_list_url <- c()

#generating urls for each states racing results over the last month
for (i in 1:length(state_list)) {
  state_list_url[[i]] <- paste0(base_url,"?State=", state_list[i])
}

#generating a list of urls to run through to get all race data for last month
results <- function(url_list){
  paste0("https://www.racingaustralia.horse",
         read_html(url_list) %>%
           html_nodes("a") %>%       
           # find all links in the page
           html_attr("href") %>%
           unique() %>%
           str_subset("/FreeFields/Results")
  )
}

#getting list of all urls with race data and converting to one list
race_results_urls <- map(state_list_url, results) %>%
  flatten() 

#separating out trial and race data
trial_results_urls <- race_results_urls[grepl("Trial", race_results_urls)]

racing_results_urls <- race_results_urls[!grepl("Trial", race_results_urls)]

#creating function to extract all tables from each url 
read_html_tbls <- function(url) {
  url = url(url, 'rb')
  html <- read_html(url) %>%
    html_table()
  
  close(url)
  return(html)
}

#creating blank list for race tables to be appended to
race_tables <- c()

#appending all race tables
race_tables <- map(racing_results_urls,read_html_tbls)

#creating blank list for trial tables to be appended to
trial_tables <- c()

#appending all race tables
trial_tables <- map(trial_results_urls,read_html_tbls)

#naming each group of tables with their date and location
names(trial_tables) <- sub('.*Key=','',trial_results_urls)


#naming each group of tables with their date and location
names(race_tables) <- sub('.*Key=','',racing_results_urls)

#removing abandoned races with no data
race_tables_non_abndn <- Filter(function(x) length(x) > 1,race_tables)

#removing abandoned races with no data
trial_tables_non_abndn <- Filter(function(x) length(x) > 1,trial_tables)

#filtering out tables that have non race results or race information
#appending race info table as a character string to the relevant race so it can be used
for (n in 1:length(race_tables_non_abndn)){
  #some days the first table is a 4 column table which contains no useful information and these are to be filtered out (on days like public holidays etc. where there are certain specialties applied by the looks of it)
  if (ncol(race_tables_non_abndn[[n]][[1]])==4){
    race_tables_non_abndn[[n]] <- race_tables_non_abndn[[n]][-1]
  } else {
    NULL
  }
  for (i in 1:length(race_tables_non_abndn[[n]])) {
    #keeping tables that are 11 columns wide - containing race data, all others containing 1 col are race info or simply abandoned races that are not useful.
    if (ncol(race_tables_non_abndn[[n]][[i]])!=11){
      NA
      } else {
        #taking useful data from previous tables and converting it into columns in current table
        race_tables_non_abndn[[n]][[i]] <-race_tables_non_abndn[[n]][[i]] %>% 
          mutate(character= as.character(race_tables_non_abndn[[n]][[i-1]]),
                 race_info = as.character(names(race_tables_non_abndn[[n]][[i-1]])),
                 info = glue("{names(race_tables_non_abndn)[[n]]}"))
      }
  }
}



#filtering out tables that have non trial results or race information
#appending race info table as a character string to the relevant race so it can be used
#running same query as above - did not create a function due to data extraction occuring once and this applying to 2 data sets - copy and paste with changes is just as time efficient as making an iterable function
for (n in 1:length(trial_tables_non_abndn)){
  if (ncol(trial_tables_non_abndn[[n]][[1]])==4){
    trial_tables_non_abndn[[n]] <- trial_tables_non_abndn[[n]][-1]
  } else {
    NULL
  }
  for (i in 1:length(trial_tables_non_abndn[[n]])) {
    if (ncol(trial_tables_non_abndn[[n]][[i]])!=11){
      NA
    } else {
      trial_tables_non_abndn[[n]][[i]] <- trial_tables_non_abndn[[n]][[i]] %>%
        mutate(character = as.character(trial_tables_non_abndn[[n]][[i-1]]),
               race_info = as.character(names(trial_tables_non_abndn[[n]][[i-1]])),
               info = glue("{names(trial_tables_non_abndn)[[n]]}"))
    }
  }
}

#flattening out both race and trial results
race_results_list <- flatten(race_tables_non_abndn)

trial_results_list <- flatten(trial_tables_non_abndn)

#keeping only tables that have anough columns to contain actual race data, not simply information regarding each race
filtered_race_results_list <- Filter(function(x) ncol(x) == 14,race_results_list)

filtered_trial_results_list <- Filter(function(x) ncol(x) == 14,trial_results_list)

#converting each list into a single df
race_results_combined <- do.call("rbind", filtered_race_results_list) 

trial_results_combined <- do.call("rbind", filtered_trial_results_list) 

#cleaning some data and extracting some information into columns for both race and trial data
race_results_combined <- race_results_combined %>%
  #removing useless columns
  select(-Colour,
         -Penalty) %>%
  mutate(Finish = as.numeric(Finish),
         #converting odds & weight to a number
         odds = as.numeric(gsub(".*?([0-9.]+).*", "\\1",`Starting Price`)),
         Weight = as.numeric(gsub("kg.*","", Weight)),
         #converting Date to an actual date in required format
         Date_format = as.Date(str_split(info, ",") %>% map_chr(., 1),
                               format('%Y%b%d')),
         #splitting the info column into useful data such as state & racecourse
         State = as.factor(str_split(info, ",") %>% map_chr(., 2)),
         Racecourse = as.factor(str_split(info, ",") %>% map_chr(., 3)),
         #getting race number
         Race = as.factor(str_extract(race_info, "^Race \\d+")),
         #converting date to a day of the week - purely as Wednesdays and Saturdays are bigger meets
         Day_of_week = as.factor(format(Date_format, '%a')),
         #getting race/trial distance
         distance = str_extract_all(race_info,"\\(\\d\\d\\d\\d METRES\\)"),
         #getting track condition which is critically important to clean properly
         track_condition = as.factor(as.character(str_extract_all(race_results_combined$character,"Track Condition: .* \\d+ T"))),
         #converting distance to number
         distance = as.numeric(str_replace_all(distance, c("\\(" = "", "METRES\\)" = ""))),
         #applying the winning time from each race to all horses in that race so an approx time for each hores could be calculated in the future
         winning_time = gsub("Time: ","",str_extract_all(character,"Time: \\d+:\\d+.\\d+ "))
         ) %>%
  na.omit() 

#applying the same logic from above to the trial race data
trial_results_combined <- trial_results_combined %>%
  select(-Colour,
         -Penalty) %>%
  mutate(Finish = as.numeric(Finish),
         odds = as.numeric(gsub(".*?([0-9.]+).*", "\\1",`Starting Price`)),
         Weight = as.numeric(gsub("kg.*","", Weight)),
         Date_format = as.Date(str_split(info, ",") %>% map_chr(., 1),
                               format('%Y%b%d')),
         State = as.factor(str_split(info, ",") %>% map_chr(., 2)),
         Racecourse = as.factor(str_split(info, ",") %>% map_chr(., 3)),
         Race = as.factor(str_extract(race_info, "^Race \\d+")),
         Day_of_week = as.factor(format(Date_format, '%a')),
         distance = str_extract_all(race_info,"\\(\\d+ METRES\\)"),
         track_condition = as.factor(as.character(str_extract_all(character,"Track Condition: .* \\d+ T"))),
         distance = as.numeric(str_replace_all(distance, c("\\(" = "", "METRES\\)" = ""))),
         winning_time = gsub("Time: ","",str_extract_all(character,"Time: \\d+:\\d+.\\d+ "))
  )

#both trial and race data contain the same columns, so an analysis can be run on both combined if required

#combining all trial and race data into one dataset
all_race_data <- rbind(race_results_combined, trial_results_combined)

#plotting head of data to enable reader to see an example of the data
reactable(head(all_race_data,1))

```


After scraping the data, it was decided to convert each horses run into an approximate time estimation, by taking each race's winning time, and then using the trailing horses distance and estimating their final time by adding time allowing for each horse to cover their losing distance at the winners average speed throughout the race. These times look like this:

```{r adding times to all horses}
# creating time function to approximate a finish time for all horses, not just winning horses
time_function <- function(dataset){
dataset$winning_time_sec<- as.numeric(gsub(":","",str_extract(dataset$winning_time,":\\d+.\\d+")))

dataset$winning_time_min <- as.numeric(str_extract(dataset$winning_time,"\\d+"))*60
dataset$winning_time_total <- dataset$winning_time_min+dataset$winning_time_sec
dataset$Margin <- gsub("L","",dataset$Margin) 
## using the assumption that a horse length is roughly 2.5 metres
dataset$Margin_Metres <- as.numeric(dataset$Margin)*2.5
dataset$winner_MperSec <- dataset$distance/dataset$winning_time_total

dataset$time <- dataset$winning_time_total+
  ifelse(is.na(dataset$Margin_Metres/dataset$winner_MperSec),
         0,
         dataset$Margin_Metres/dataset$winner_MperSec)
return(dataset)
}

#calculating times for all races - hoping this helps improve accuracy
all_race_data <- time_function(all_race_data)

reactable(head(all_race_data %>%
        select(Horse,
               Jockey,
               Trainer,
               distance,
               Margin,
               winning_time_total,
               time)))

```

## Choose a Tab {.tabset .tabset-fade .tabset-dropdown}
### Assessing Favouritism

In this section, a brief assessment of the favouritism is assessed. Specifically, how often the favourite (the horse with the lowet odds at the time of the race) wins. 

```{r basic plot}
##cleaning the race data a little bit more before getting into some exploratory analysis 
all_race_data_clean <- all_race_data %>%
  select(-winning_time,
         -winning_time_sec,
         -winning_time_min,
         -winning_time_total,
         -winner_MperSec) %>%
  mutate(RaceID = paste(info,",",Race),
         ID = paste(info,",",Race,"Finish-", Finish),
         Margin_Metres = ifelse(is.na(Margin_Metres)==T, 0, Margin_Metres),
         winner = ifelse(Finish==1,1,0),
         track_condition = gsub('.{2}$','',track_condition),
         Weight = ifelse(is.na(Weight),0,Weight),
         Race_time = str_extract(race_info,"\\d+:\\d+[AP]M"),
         Datetime = as.POSIXct(paste(Date_format, " ", Race_time), format = "%Y-%m-%d %I:%M%p")) %>%
  filter(time >0,
         is.na(Finish)!=T,
         track_condition!="character(") %>%
  arrange(Datetime,RaceID, Finish) %>%
  group_by(RaceID) %>%
  mutate(favourite = ifelse(odds == min(odds),1,0),
         fav_winner = ifelse(favourite ==1 & winner ==1,1,0)) %>%
  ungroup() %>%
  na.omit() %>%
  data.frame()


## Assessing how often the favourite wins
fav_win_odds <- all_race_data_clean %>%
  filter(!is.na(odds)) %>%
  group_by(Date_format) %>%
  summarise(num_fav_winners = sum(fav_winner, na.rm = T),
            races = length(unique(RaceID)),
            fav_win_odds = (num_fav_winners/races)*100)


##Plotting favourite winning rate per day over the previous month
ggplot(fav_win_odds) +
  geom_line(aes(x=Date_format, y = fav_win_odds))+
  geom_line(aes(x=Date_format, y = mean(fav_win_odds)), colour = "blue")+
  labs(title = "Percentage of favourites that win each day",
       x= "Date",
       y = "percentage of favourites to win")+
  theme_minimal()
```

After seeing that the favourite wins approximately 40% of the time, a quick trial of how betting $100 on every favourite would turn out financially was run, with the results being below. 

```{r plot2}
## looking at how you end up if you bet $100 on every favourite
every_favourite <- all_race_data_clean %>%
  #only need the favourite for each race
  filter(favourite ==1) %>%
  arrange(Datetime,RaceID) %>%
  ungroup() %>%
  mutate(race_result = ifelse(winner ==1,(100*odds)-100,-100),
         cumulative_race_total = cumsum(race_result)) %>%
  group_by(Date_format) %>%
  slice(c(n()))

#plotting outcomes if a bet on every favourite is placed
ggplot(every_favourite) +
  geom_line(aes(x=Date_format,y=cumulative_race_total)) +
  labs(title = "Cumulative profits while betting on every favourite",
       x = "Date",
       y = "Cumulative profits") +
  theme_minimal()
```

Seeing the variability in cashflows, and that this run ends with losing money, it it not simply enough to rely on the odds of the bookmaker and the public. It is important that we try to predict a winner. To do this initially, a generalized linear model is used to model a winning horse, using important variables such as the barrier, weight, track condition, and distance. Variables such as Horse, Jockey and Trainer have been excluded initially as these variables may only appear once or not at all in the training set, and there is not enough data to include variables that have values occuring once or not at all.

```{r winners, results='markup'}
#splitting data by date to use last 2 days as test data, the rest as train data
train_horse_data <- all_race_data_clean[!all_race_data_clean$Datetime>=max(all_race_data_clean$Datetime)-days(2),]
test_horse_data <- all_race_data_clean[all_race_data_clean$Datetime>=max(all_race_data_clean$Datetime)-days(2),]

#creating basic glm to predict winning horse
glm_winner <- glm(data = train_horse_data, formula = winner ~ Bar. + Weight + track_condition + distance + odds, family=binomial)

#summary of glm model shows barrier and weight are only significant variables
summary(glm_winner)

#attempting to predict winner through glm
fitted.results <- predict(glm_winner,
                          newdata=test_horse_data,type='response')

#fitted.results <- ifelse(fitted.results > 0.5,1,0)
##oh no, glm dont predict any horses winning
glue("The GLM's largest prediction for a horse winning is {round(max(fitted.results)*100,2)}%")
```

The GLM found no way to make any predictions where a horse would win, it was decided that we will try using a random forest to predict some winning horses via classification. 

```{r random forest}
library(randomForest)
#random forest
rf_winner <- randomForest(data = train_horse_data,winner ~ Bar. + Weight + track_condition + distance + odds, importance = TRUE)
# random forest model summary
rf_winner

#predicting horse races on the test set
predTrain <- predict(rf_winner, test_horse_data, type = "class")
#converting the prediction probability to a simply win or no win
predTrain <- ifelse(predTrain>=0.5,1,0)

#table of predicted vs actual
cat("Predicted against actual results")
table(test_horse_data$winner,predTrain)

#randomforest model summary stats in sentence. 
cat(glue("The Random forest does not predict a lot of horses to win (only {sum(predTrain==1)}), however its total accuracy of {round(mean(predTrain == test_horse_data$winner)*100,2)}% is quite impressive."))

#testing to see if betting on these races can be profitable
test_horse_data_rf_bet <- test_horse_data %>% 
  mutate(pred = predTrain) %>%
  filter(pred == 1) %>%
  #calculating required bet amount to profit $100 if the horse wins
  mutate(bet = 100/(odds-1),
         profit = ifelse(winner==1,(bet*odds)-bet,-bet),
         roll_total = cumsum(profit))


reactable(test_horse_data_rf_bet %>%
        select(Horse,
               RaceID,
               Bar.,
               Weight, 
               distance, 
               track_condition, 
               odds, 
               winner, 
               bet, 
               profit,
               roll_total))
```

Whilst we can see this random forest does predict accurately, we were hoping for better in the prediction department. Maybe if we use some machine learning we can get some better predictions. Lets have a look at how a neural network goes with predicting winning horses. 


```{r neural net, echo=TRUE, results='hide'}

#train_params <- trainControl(method = "repeatedcv", number = 3, repeats=2)
nn_train_df <- train_horse_data %>% 
                      select(Bar.,Weight, track_condition, distance, odds)

nnet_model <- train(nn_train_df,
                    train_horse_data$winner,
                    method = "nnet",
                    #trControl= train_params,
                    na.action = na.omit
)
```

```{r nnet part2}
#Predictions on the test set
nnet_predictions_test <-ifelse(predict(nnet_model, test_horse_data)>=0.5,1,0)

#plotting neuralnet to show
plotnet(nnet_model$finalModel, y_names = "Racing Factors")
title("Graphical Representation of Horse Racing Neural Network")


# Confusion matrix on test set
table(test_horse_data$winner, nnet_predictions_test)
```


From the above, we can see that the neural net does predict more horses to win than the random forest, however its prediction of which horses will win is lower than the random forest. When selecting a model to pick a winning horse, a random forest would be used with the chosen variables used. 

In future modifications of this analysis, more data will be used and a prediction on time will be analysed using factors such as the horse, trainer and jockey, however as most horses in this data only appear once, training a model on the horse, jockey and trainer is not useful, and may also be biased towards certain trainers and Jockeys who simply train/ride better horses due to their experience and success level (think of Gai Waterhouse and Damian Oliver as examples)

### Making money

It has occurred to me that since favourites win approximately 40% of the time, it would be entirely possible to double down on betting each day until a favourite wins to generate a specified income daily - for lack of a better term, essentially making gambling on horses a side hustle with a certain level of calculated risk (being the risk that your daily required betting increases over your initial balance).

For this to work, the user would need a decent pool of available cash on hand, to sustain increasing bets until a winner pays out and returns all previous bets plus desired winnings. The other most important factor, would be that the better quits after winning their desired amount for that day. This essentially means that if the first favourite wins, the bettor is finished after one race for that day. If it takes 7 races for a favourite to win, the bettor will wager on all 7 races with increasing amounts until a winner emerges resulting in all outlayed bets repayed, along with the desired profit. 


```{r making money }
#attempting to create a betting system on favourites where bets grow larger to recoup losses until a winner is picked providing the desired profit


daily_profit_function <- function(race_data, desired_profit_daily = 200){
fav_betting_system_df <- race_data %>%
  #only need favourites
  filter(favourite == 1) %>%
  #arranging by time to align with real life and multiple tracks on same day, and barrier to remove any horses where there are multiple favourites so only a single fav is chosen for each race
  arrange(Datetime, Bar.) %>%
  #selecting single fav for each race
  distinct(Datetime, .keep_all =T) %>%
  #calculating required bet wo win $200 of that race
  mutate(bet = NA,
         new_bet = NA,
         total_outlay = NA) 

#calculating the bet amount for each individual race, and the total outlay, for races after an initial race has failed. so all bet amounts would be taken off the new_bet once this is complete
for (i in 1:nrow(fav_betting_system_df)){
  if (i==1){
    fav_betting_system_df$bet[[i]] <- 1
    fav_betting_system_df$new_bet[[i]] <- desired_profit_daily/(fav_betting_system_df$odds[[i]]-1)
    fav_betting_system_df$total_outlay[[i]] <- desired_profit_daily/(fav_betting_system_df$odds[[i]]-1)
  } else if(fav_betting_system_df$Date_format[[i]] != fav_betting_system_df$Date_format[[i-1]]) {
    fav_betting_system_df$bet[[i]] <- 1
    fav_betting_system_df$new_bet[[i]] <- desired_profit_daily/(fav_betting_system_df$odds[[i]]-1)
    fav_betting_system_df$total_outlay[[i]] <- desired_profit_daily/(fav_betting_system_df$odds[[i]]-1)
  } else {
    fav_betting_system_df$bet[[i]] <- ifelse(fav_betting_system_df$bet[[i-1]]==0,
                                             0,
                                             ifelse(fav_betting_system_df$winner[[i-1]]==1,
                                                    0,
                                                    1))
    fav_betting_system_df$new_bet[[i]] <- ifelse(fav_betting_system_df$bet[[i]]==1,(fav_betting_system_df$total_outlay[[i-1]]+desired_profit_daily)/(fav_betting_system_df$odds[[i]]-1),0)
    fav_betting_system_df$total_outlay[[i]] <- ifelse(fav_betting_system_df$bet[[i]]==1, (fav_betting_system_df$total_outlay[[i-1]]+fav_betting_system_df$new_bet[[i]]),0)
  }
}

return(fav_betting_system_df)
}

graph_daily_bets <- function(profit_data){
#quick plot of number of bets per day to get a winner
ggplot(profit_data %>% group_by(Date_format) %>%
          summarise(numbets_day = sum(bet))) +
   geom_line(aes(x=Date_format, y = numbets_day))+
    labs(title = "plot of number of bets per day to get a winner",
         x = "Date",
         y = "Number of daily bets required until a favourite wins")

}

graph_daily_profits <- function(profit_data){
#quick plot of maximum amount required for any single day of betting to get a winner over the previous month
ggplot(profit_data %>% group_by(Date_format) %>%
         summarise(maxbet = max(total_outlay))) +
   geom_line(aes(x=Date_format, y = maxbet))+
    labs(title = "plot of maximum amount required for any single day of betting to get a winner",
         x = "Date",
         y = "Total money required to 'double down'")
}

graph_total_profits <- function(profit_data){
  ggplot(profit_data %>% 
           #filtering for only races we bet on now
            filter(bet ==1) %>%
            mutate(profits = ifelse(winner ==1,(new_bet*odds)-new_bet,-new_bet),
            roll_profits = cumsum(profits))) +
    geom_line(aes(x = Datetime, y = roll_profits))+
    labs(title = "accumulative profits through time",
         x = "Time",
         y = "Accumulative profits")
}

profit_system_df_function <- function(profit_data){
fav_betting_system_df_bets <- profit_data %>%
  #filtering for only races we bet on now
  filter(bet ==1) %>%
  mutate(profits = ifelse(winner ==1,(new_bet*odds)-new_bet,-new_bet),
         roll_profits = cumsum(profits))
return(fav_betting_system_df_bets)
}

```

Below a simulation on the last months worth of horse racing data has been run, and for different desired winning amounts, the amount of initial funds required obviously varies depending on the desired daily win amount. Below are runs of 50 dollars daily profit, 100 dollars daily profit, and 200 dollars daily profit

#### $50 profit Daily

```{r profit 50 daily}
profit_50_daily <- daily_profit_function(all_race_data_clean, 50)
graph_daily_bets(profit_50_daily)
graph_daily_profits(profit_50_daily)
graph_total_profits(profit_50_daily)
reactable(profit_system_df_function(profit_50_daily) %>% select(-character,
                                                                -info,
                                                                -race_info))
```

#### $100 profit Daily

```{r profit 100 daily}
profit_100_daily <- daily_profit_function(all_race_data_clean, 100)
graph_daily_profits(profit_100_daily)
graph_total_profits(profit_100_daily)
reactable(profit_system_df_function(profit_100_daily) %>% select(-character,
                                                                -info,
                                                                -race_info))
```

#### $200 profit Daily

```{r profit 200 daily}
profit_200_daily <- daily_profit_function(all_race_data_clean, 200)
graph_daily_profits(profit_200_daily)
graph_total_profits(profit_200_daily)
reactable(profit_system_df_function(profit_200_daily) %>% select(-character,
                                                                -info,
                                                                -race_info))
```

From the above you can see that to systematically run a profitable system daily off horse racing, you would need a substantial amount of initial funds however a system like this seems as if it could be run to generate tax free profits.

I am curious if investors with a decent amount of free cash would spend their time betting with a system like this. I am also curious if there are any regulations or rules against betting in a system like shown above, and if gambling companies are testing and assessing their customers habits for systematic attempts to profit off their business?